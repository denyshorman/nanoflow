package io.github.denyshorman.nanoflow.operators;

import io.github.denyshorman.nanoflow.Flows;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

class OpenTest {
    @Test
    void shouldIterateWithOpenAndForLoop() {
        var flow = Flows.of(1, 2, 3);
        var values = new ArrayList<Integer>();

        try (var items = flow.open()) {
            for (var item : items) {
                values.add(item);
            }
        }

        assertEquals(List.of(1, 2, 3), values);
    }

    @Test
    void shouldIterateEmptyFlowWithOpen() {
        var flow = Flows.<Integer>empty();
        var values = new ArrayList<Integer>();

        try (var items = flow.open()) {
            for (var item : items) {
                values.add(item);
            }
        }

        assertEquals(List.of(), values);
    }

    @Test
    void shouldStopProducerWhenLoopBreaks() throws InterruptedException {
        var finished = new CountDownLatch(1);

        var flow = Flows.<Integer>flow(emitter -> {
            try {
                var i = 0;
                while (!Thread.currentThread().isInterrupted()) {
                    emitter.emit(i++);
                }
            } finally {
                finished.countDown();
            }
        });

        try (var items = flow.open()) {
            for (var item : items) {
                if (item == 2) {
                    break;
                }
            }
        }

        assertTrue(finished.await(30, TimeUnit.SECONDS));
    }

    @Test
    void shouldCloseWhenLoopThrows() throws InterruptedException {
        var finished = new CountDownLatch(1);

        var flow = Flows.<Integer>flow(emitter -> {
            try {
                var i = 0;
                while (!Thread.currentThread().isInterrupted()) {
                    emitter.emit(i++);
                }
            } finally {
                finished.countDown();
            }
        });

        assertThrows(IllegalStateException.class, () -> {
            try (var items = flow.open()) {
                for (var item : items) {
                    if (item == 2) {
                        throw new IllegalStateException("boom");
                    }
                }
            }
        });

        assertTrue(finished.await(30, TimeUnit.SECONDS));
    }

    @Test
    void shouldPropagateEmitterExceptionDuringIteration() {
        var flow = Flows.<Integer>flow(emitter -> {
            emitter.emit(1);
            throw new IOException("boom");
        });

        assertThrows(IOException.class, () -> {
            try (var items = flow.open()) {
                for (var item : items) {
                    assertEquals(1, (int) item);
                }
            }
        });
    }
}
